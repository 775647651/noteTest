# 1.Zookeeper

## 简单的功能（Znode+监听）：

1.统一命名管理：多个计算机IP合成一个域名，通过域名即可访问

2.统一配置管理：多个系统合用一个配置文件，挂在znode上。（监听！）

3.分布式锁：访问节点时创建临时的节点，临时节点id最小的可以访问。（监听！）



# 2.Redis

1.Strings 字符串

2.lists      字符串列表

3.sets     字符串集合

4.sorted sets     有序字符串集合

5.hash 哈希

## 2.持久化

RDB和AOF（都是先保存到临时文件中）

RDB:单独fork一个线程，隔一段时间就把内存中数据以快照形式保存到磁盘的二进制文件。

AOF：默认情况下每秒钟都将新的写指令都记录到文件最后，数据恢复时就只需要重新执行这个文件。（体积大、速度慢）

默认是AOF

## 3.缓存穿透、缓存击穿、缓存雪崩区别和解决方案

**穿透： 缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。**

方案：

1.设置null值的缓存，设置短过期时间。

2.使用bitmap，设置白名单。

3.使用布隆过滤器，bitmap的高效率版。

  **缓存击穿：是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力**

方案：

1.设置热点key永不过期

2.加排他锁。每次访问数据库就判断这个锁。

3.预设一下热门的数据。

 **缓存雪崩：是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，    缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。**

1.使用互斥锁或者队列去解决。来避免大量请求的并发请求数据库。

2.不同的key设置随机的过期时间，这样可以避免大规模的key过期。

## 4.redis的过期策略以及内存淘汰机制

**采用了定期删除和惰性删除的策略**

每隔100ms随机抽取key进行检查是否过期，过期则删除，而惰性删除则是在每次读取缓存之前，先判断缓存是否过期。但这两种方案也可能会存在漏网之鱼，于是会导致越积越多，于是就要配置redis.conf里的参数

```
maxmemory-policy volatile-lru；
```

2）allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。推荐使用，目前项目在用这种。

## 5.单线程为什么这么快?

Redis的性能非常之高，每秒可以承受10W+的QPS，它如此优秀的性能主要取决于以下几个方面：

- Redis大部分操作在内存完成(高效的数据结构，例如哈希表和跳表)
- 采用IO多路复用机制(基于 Reactor 模式开发了使用io多路复用程序监听套接字的文件事件处理器)
- 非CPU密集型任务
- 单线程的优势

## 6.分布式锁的优势

相比普通的