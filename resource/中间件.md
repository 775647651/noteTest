# 1.Zookeeper

## 简单的功能（Znode+监听）：

1.统一命名管理：多个计算机IP合成一个域名，通过域名即可访问

2.统一配置管理：多个系统合用一个配置文件，挂在znode上。（监听！）

3.分布式锁：访问节点时创建临时的节点，临时节点id最小的可以访问。（监听！）



# 2.Redis

1.Strings 字符串

2.lists      字符串列表

3.sets     字符串集合

4.sorted sets     有序字符串集合

5.hash 哈希

## 2.持久化

RDB和AOF（都是先保存到临时文件中）

RDB:单独fork一个线程，隔一段时间就把内存中数据以快照形式保存到磁盘的二进制文件。

AOF：默认情况下每秒钟都将新的写指令都记录到文件最后，数据恢复时就只需要重新执行这个文件。（体积大、速度慢）。因为采用了追加方式，如果不做任何处理的话，AOF文件会变得越来越大，为此，redis提供了AOF文件重写（rewrite）机制，只保留可以恢复数据的最小指令集。

默认是AOF

## 3.缓存穿透、缓存击穿、缓存雪崩区别和解决方案

**穿透： 缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。**

方案：

1.设置null值的缓存，设置短过期时间。

2.使用bitmap，设置白名单。

3.使用布隆过滤器，bitmap的高效率版。

  **缓存击穿：是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力**

方案：

1.设置热点key永不过期

2.加排他锁。每次访问数据库就判断这个锁。

3.预设一下热门的数据。

 **缓存雪崩：是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，    缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。**

1.使用互斥锁或者队列去解决。来避免大量请求的并发请求数据库。

2.不同的key设置随机的过期时间，这样可以避免大规模的key过期。

## 4.redis的过期策略以及内存淘汰机制

**采用了定期删除和惰性删除的策略**

每隔100ms随机抽取key进行检查是否过期，过期则删除，而惰性删除则是在每次读取缓存之前，先判断缓存是否过期。但这两种方案也可能会存在漏网之鱼，于是会导致越积越多，于是就要配置redis.conf里的参数

```
maxmemory-policy volatile-lru；
```

2）allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。推荐使用，目前项目在用这种。

## 5.单线程为什么这么快?

Redis的性能非常之高，每秒可以承受10W+的QPS，它如此优秀的性能主要取决于以下几个方面：

- Redis大部分操作在内存完成(高效的数据结构，例如哈希表和跳表)
- 采用IO多路复用机制(基于 Reactor 模式开发了使用io多路复用程序监听套接字的文件事件处理器)
- 非CPU密集型任务
- 单线程的优势（避免切换）

## 6.分布式锁的优势

相比普通的

## 7.网络编程

1、第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN（c）。此时客户端处于 SYN_Send 状态。

2、第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。

3、第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 establised 状态。

4、服务器收到 ACK 报文之后，也处于 establised 状态，此时，双方以建立起了链接。



### 8.具体代码

![image-20220426222329874](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20220426222329874.png)