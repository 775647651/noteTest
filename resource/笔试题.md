#### **1、Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？**

Math.round(11.5):12，Math.round(-11.5):-11。四舍五入的原理是在参数上加0.5然后进行下取整。

#### 2.**switch 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上？**

expr只能是byte、short、char、int、String

#### 3.、数组有没有length()方法？String有没有length()方法？**

数组有length 的属性。String 有length()方法。JavaScript中，获得字符串的长度是通过length属性得到的。

#### **4.重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？**

同样的方法名，重载指不同参数列表，对返回类型没要求，是编译时的多态性。重写指子类继承父类已有或抽象方法，是运行时的多态性。

#### **5、char 型变量中能不能存贮一个中文汉字，为什么？**

答：char类型可以存储一个中文汉字，因为Java中使用的编码是Unicode（不选择任何特定的编码，直接使用字符在字符集中的编号，这是统一的唯一方法），一个char类型占2个字节（16比特），所以放一个中文是没问题的。

#### 6.**静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？**

Static 不依赖外部实例化而实例化，inner必须外部类实例化后才实例化

#### 7.抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰？

答：都不能。抽象方法需要子类重写，而静态的方法是无法被重写的。本地方法是由本地代码实现的方法，而抽象方法是没有实现的。synchronized和方法的实现细节有关，抽象方法不涉及实现细节。

#### 8、阐述静态变量和实例变量的区别。

答：静态变量是被static修饰符修饰的变量，也称为类变量，它属于类，静态变量在内存中有且仅有一个拷贝；实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。

#### **9.是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？**

答：不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，在调用静态方法时可能对象并没有被初始化。

#### **10.String s = new String("xyz");创建了几个字符串对象？**

答：两个对象，一个是静态区的"xyz"，一个是用new创建在堆上的对象。



#### 11.**接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete class）？**

答：接口可以继承接口，而且支持多重继承。抽象类可以实现(implements)接口，抽象类可继承具体类也可以继承抽象类。



#### **12.Java 中的final关键字有哪些用法？**

答：(1)修饰类：表示该类不能被继承；(2)修饰方法：表示方法不能被重写；(3)修饰变量：表示变量只能一次赋值以后值不能被修改（常量）。



#### 13.数据类型之间的转换：

- 如何将字符串转换为基本数据类型？
- 如何将基本数据类型转换为字符串？
答：

1.包装类：parseXXX(String)或valueOf(String）
2.一种方法是将基本数据类型与空字符串（""）连接（+）即可获得其所对应的字符串；另一种方法是调用valueOf()方法返回相应字符串

#### 14、如何实现字符串的反转及替换？

答：方法很多，可以自己写实现也可以使用String或StringBuffer/StringBuilder中的方法。

	public static String reverse(String originStr) {
		if(originStr == null || originStr.length() <= 1) 
			return originStr;
		return reverse(originStr.substring(1)) + originStr.charAt(0);
	}
#### **15.怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？**

```Java
String s1 = "你好";
String s2 = new String(s1.getBytes("GB2312"), "ISO-8859-1");
```

#### **16、比较一下Java和JavaSciprt。**

1.面向对象和基于对象。

2.需要编译，js不用编译，解释执行的。（静态语言和动态语言）

3.强类型变量和弱类型变量。

4.不同代码格式。

#### 17.**Error和Exception有什么区别？**

1.Error一般是系统级的错误并且程序没必要处理，例子：内存溢出。不可能指望能处理。

2.Exception是需要捕获或进行处理的异常。是设计或者实现的问题。

#### 18、创建[多线程](https://so.csdn.net/so/search?q=多线程)时，继承Thread类好还是实现Runnable接口好？

​    实现Runnable接口好，因为实现了Runnable接口还可以继续继承其他类，如果继承了Thread类就不能再继承其他类了。

#### 19.**两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？**

不对，两个对象值相同，hashcode一定相同。hashcode相同，对象不一定相同。

#### 20**.throws、throw、try、catch、finally分别如何使用？**

throws一般用来声明一个方法可能产生的异常，throw就是确定抛出一个异常，try就是用来指定预防异常的代码块，catch就紧跟在try后面对发生的指定的异常进行捕获，finally确保一个不管发生什么异常他都会执行的代码块。

#### 21、阐述final、finally、finalize的区别。

答：

final：修饰符（关键字）有三种用法：如果一个类被声明为final，意味着它不能再派生出新的子类，即不能被继承。将变量声明为final，可以保证它们在使用中不被改变，被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取不可修改。被声明为final的方法也同样只能使用，不能在子类中被重写。
finally：通常放在try…catch…的后面构造总是执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要JVM不关闭都能执行，可以将释放外部资源的代码写在finally块中。
finalize：Object类中定义的方法，Java中允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，作用是在对象被销毁之前做一些处理把。

#### **22、List、Set、Map是否继承自Collection接口？**

答：List和set继承自Collection接口而Map不是，List和set有很大区别的。List是底层数组实现的，是线性结构存储容器，适用于按数组索引访问元素，Set存储零散的元素且元素不可重复的。Map则是键值对映射存储的。

#### **23、Collection和Collections的区别？**

collection是接口，Set、List、queue的父接口。Collections则是一个工具类，提供了包括排序、搜索等一些辅助容器操作的静态方法。

#### 24、List、Map、Set三个接口存取元素时，各有什么特点？

答：List以特定序号索引来存取元素，可以有重复元素。Set不能存放重复元素。Map保存键值对（key-value pair）映射，映射关系可以是一对一或多对一。Set和Map容器都有基于哈希存储和排序树的两种实现版本，基于哈希存储的版本理论存取时间复杂度为O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。

#### 25、TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？

答：TreeSet要求存放的对象所属的类必须实现Comparable接口，该接口提供了比较元素的compareTo()方法，当插入元素时会回调该方法比较元素的大小。TreeMap要求存放的键值对映射的键必须实现Comparable接口从而根据键对元素进行排序。Collections工具类的sort方法有两种重载的形式，第一种要求传入的待排序容器中存放的对象比较实现Comparable接口以实现元素的比较；第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator接口的子类型（需要重写compare方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java中对函数式编程的支持）。



#### **26.Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别?**

1.sleep（）是线程类的静态方法，而wait（）是Object的一个方法。

2.（锁和状态池的角度）slepp（）会让线程暂停执行指定的时间，进入阻塞状态，但是他会保持对象锁，因此他在休眠时间结束之后会自动恢复到就绪状态。wait（）方法线程放弃对象锁，进入等待池，在notify（）或者notifyaLL()方法之后会进入等锁池，若取得对象锁之后他就恢复到就绪状态。



#### 27.线程的sleep()方法和yield()方法有什么区别？

答：
① sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；
② 线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态；
③ sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常；
④ sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性。、



#### 28.当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？

答：不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的synchronized修饰符要求执行方法时要获得对象的锁，如果已经进入A方法说明对象锁已经被取走，那么试图进入B方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁。



#### 29.请说出与线程同步以及线程调度相关的方法。

答：

wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；
sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理InterruptedException异常；
notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关；
notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；



#### 30.**synchronized关键字的用法？**

答：synchronized关键字可以将对象或者方法标记为同步，以实现对对象和方法的互斥访问，可以用synchronized(对象) { … }定义同步代码块，或者在声明方法时将synchronized作为方法的修饰符。



#### 31.举例说明同步和异步。（改）

答：如果系统中存在临界资源（资源数量少于竞争资源的线程数量的资源），例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就必须进行同步存取（数据库操作中的排他锁就是最好的例子）。当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。事实上，所谓的同步就是指阻塞式操作，而异步就是非阻塞式操作。

#### **32、启动一个线程是调用run()还是start()方法？**

答：启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM 调度并执行，这并不意味着线程就会立即运行。run()方法是线程启动后要进行回调（callback）的方法。



#### 33、什么是线程池（thread pool）？

答：在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在Java中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就是"池化资源"技术产生的原因。线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。
Java 5+中的Executor接口定义一个执行线程的工具。它的子类型即线程池接口是ExecutorService。要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，因此在工具类Executors面提供了一些静态工厂方法，生成一些常用的线程池，如下所示：

newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。
newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。
newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。
newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。
newSingleThreadExecutor：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。
