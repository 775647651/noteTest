# 1.JVM

## 一.说一下 JVM 的主要组成部分及其作用？

![img](https://img-blog.csdnimg.cn/20200103213149526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)





## 二.JVM运行机制

JVM全称是 Java Virtual Machine ，中文称为 Java虚拟机 。

  JVM是Java程序运行的底层平台，与Java支持库一起构成了Java程序的执行环境。分为JVM规范和JVM实现两个部分。简单来说，Java虚拟机就是指能执行标准Java字节码的虚拟计算机。



## 三.JVM知识点

### 1.JVM内存泄漏

原因：长生命周期持有短生命周期引用

办法：

1.object = null  这样就会被gc回收

2.解决的原则就是尽量减小对象的作用域



### 2.GC

#### **1.释放对象的根本原则就是对象不会再被使用**：

触发情况是虚拟机空闲或者堆内存不够

#### 2.GC是什么？为什么要GC？GC的好处？

GC就是垃圾回收，GC是低优先级别的。GC可以清理没有用的对象来释放内存，可以防止内存泄漏。

#### 3.垃圾回收机制有哪些。

垃圾回收有分代复制垃圾回收、标记垃圾回收、增量垃圾回收。

#### 4.垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？

答1：创建对象的时候，gc就会监控对象的地址、内存、使用的情况。

gc通过有向图会管理对象，通过这种方式找到不会再被的引用的对象。

答2：可以马上回收。

答3：System.gc（）；

#### 5*.Java 中都有哪些引用类型？

强引用：发生 gc 的时候不会被回收。
软引用：有用不必须。在发生内存溢出之前会被回收。
弱引用：在下一次GC时会被回收。
虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。

#### 6.怎么判断对象是否可以被回收？

1.引用计数器：计数器为0可以被回收；引用加1，释放-1.

2.可达性：从GCRoots（虚拟机栈对象、常量、静态变量、方法栈引用的对象）向下搜索。



#### 7.说一下堆栈的区别？

物理地址

堆的物理地址分配对对象是不连续的。因此性能慢些。在GC的时候也要考虑到不连续的分配，所以有各种算法。比如，标记-消除，复制，标记-压缩，分代（即新生代使用复制算法，老年代使用标记——压缩）

栈使用的是数据结构中的栈，先进后出的原则，物理地址分配是连续的。所以性能快。

内存分别

堆因为是不连续的，所以分配的内存是在运行期确认的，因此大小不固定。一般堆大小远远大于栈。

栈是连续的，所以分配的内存大小要在编译期就确认，大小是固定的。

存放的内容

堆存放的是对象的实例和数组。因此该区更关注的是数据的存储

栈存放：局部变量，操作数栈，返回结果。该区更关注的是程序方法的执行。

PS：

静态变量放在方法区
静态的对象还是放在堆。
程序的可见度

堆对于整个应用程序都是共享、可见的。

栈只对于线程是可见的。所以也是线程私有。他的生命周期和线程相同。



#### 8.常用的 JVM 调优的参数都有哪些？

-Xms2g：初始化推大小为 2g；
-Xmx2g：堆最大内存为 2g；
-XX:+PrintGC：开启打印 gc 信息；
-XX:+PrintGCDetails：打印 gc 详细信息。



#### 9.说一下 JVM 调优的工具？

JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。

jconsole：用于对 JVM 中的内存、线程和类等进行监控；
jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。



#### 10.说一下类装载的执行过程？

类装载分为以下 5 个步骤：

加载：根据查找路径找到相应的 class 文件然后导入；
验证：检查加载的 class 文件的正确性；
准备：给类中的静态变量分配内存空间；
解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；
初始化：对静态变量和静态代码块执行初始化工作。



#### 11.什么是类加载器，类加载器有哪些?

实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。

主要有一下四种类加载器:

启动类加载器(Bootstrap ClassLoader)用来加载java核心类库，无法被java程序直接引用。
扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。
系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。
用户自定义类加载器，通过继承 java.lang.ClassLoader类的方式实现。

#### 12.描述一下JVM加载Class文件的原理机制

Java中的所有类，都需要由类加载器装载到JVM中才能运行。类加载器本身也是一个类，而它的工作就是把class文件从硬盘读取到内存中。在写程序的时候，我们几乎不需要关心类的加载，因为这些都是隐式装载的，除非我们有特殊的用法，像是反射，就需要显式的加载所需要的类。

类装载方式，有两种 ：

1.隐式装载， 程序在运行过程中当碰到通过new 等方式生成对象时，隐式调用类装载器加载对应的类到jvm中，不用关心类的装载。

2.显式装载， 通过class.forname()等方法，显式加载需要的类，反射

Java类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类(像是基类)完全加载到jvm中，至于其他类，则在需要的时候才加载。这当然就是为了节省内存开销。

#### 13.简述java类加载机制?

虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，解析和初始化，最终形成可以被虚拟机直接使用的java类型。