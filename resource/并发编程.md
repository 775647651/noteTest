# 并发编程

![image-20220217221213148](C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20220217221213148.png)

![这里写图片描述](https://img-blog.csdnimg.cn/img_convert/b01dda620b25be81119f104146111cd4.png)



1. **新建(NEW)**：新创建了一个线程对象。

2. **可运行(RUNNABLE)**

3. **运行(RUNNING)**
4. **阻塞(BLOCKED)**

> (一). 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。
> (二). 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。
> (三). 其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。

5. **死亡(DEAD)**：线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。



### **2.创建线程的两种方法（在java中线程使用两种方法）**

- **继承Thread类，重写run方法**
- **实现Runnable接口，重写run方法**

### **3.执行main方法，启动了一个进程，也启动了一个main线程。所有线程结束之后进程结束。**

进程是内存的基本单位，线程是调度资源的基本单位。

### **4.线程的常用方法**

```java
1.setName //设置线程名称，使之与参数name 相同。
2.getName//返回该线程的名称。
3.start   //使该线程开始执行;Java虚拟机底层调用该线程的start0方法。
4.run   /调用线程对象 run方法;
5.setPriority //更改线程的优先级
6.getPriority //获取线程的优先级
7.sleep  /在指定的毫秒数内让当前正在执行的线程休眠（暂停执行)
8.interrupt M/中断线程 
9.yield:线程的礼让。让出cpu,让其他线程执行，但礼让的时间不确定，所以也不一定礼让成功
10.join:线程的插队。插队的线程一旦插队成功，则肯定先执行完插入的线程所有的任务
    
    
用户线程和守护线程
1.用户线程:也叫工作线程，当线程的任务执行完或通知方式结束
2.守护线程:一般是为工作线程服务的，当所有的用户线程结束，守护线程自动结束
3.常见的守护线程:垃圾回收机制  setDaemon（）设置守护线程



```

# 问题：

### 1.为什么是start启动线程呢？

**1.实际上是调用底层的start0（）方法，native方法，通过JVM使线程进入一个可执行状态。run的话只是一个普通方法。**



### 2.继承Thread（）和实现Runnable的区别？

**1.本质上没有区别，Thread也是实现Runnable接口的，实质都是调用底层Runnable接口的start中的start0（）方法。**

**2.并且实现runnable避免了单继承。**

### 3.interrupt 不是中止，而是中断线程，即是抛出interruptedException异常